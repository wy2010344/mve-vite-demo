import{by as h}from"./index-DzjyJcX9.js";import{A as y,U as V,a,F as w,i as A}from"./index-hd7qkCj1.js";import{p as F}from"./kanren-DfUmp-DM.js";import{toIntersect as d}from"./intersect-BrkOqI9c.js";function m(r,t,i){if(i)throw t;r.messages.push({type:"error",value:t})}function v(r,t,i,e){const[l]=u(r,i,e),[f]=u(t,i,e);if(!(f instanceof w))return m(t,"不是函数类型",e),[y.empty,i];if(!A(f.arg,l))return m(r,"不是子集",e),[y.empty,i];if(e)return[f.apply(l),i];try{return[f.apply(l),i]}catch(n){return m(r,n+"",e),[y.empty,i]}}function u(r,t,i){if(r.type=="infix"){const e=r.infix.value;if(e=="+"){const[l]=u(r.left,t,i),[f]=u(r.right,t,i);return[F(l,f),t]}else if(e==":"){const l=r.left;if(l.type!="ref"&&l.type!="string")return m(l,"目前只支持symobl与string类型",i),[y.empty,t];const f=l.value,[n]=u(r.right,t,i);return[new h(f,n),t]}else if(e=="|"){const[l]=u(r.left,t,i),[f]=u(r.right,t,i);return[V.from(l,f),t]}else if(e=="&"){const[l]=u(r.left,t,i),[f]=u(r.right,t,i);return[d(l,f),t]}else if(e=="="){const l=r.left;if(l.type=="ref"){const f=l.value,[n]=u(r.right,t,i);return i||l.messages.push({type:"type",value:a(n)}),[y.empty,new h(f,n,t)]}else return m(l,"不支持这种值的绑定",i),[y.empty,t]}else if(e==","){const[l,f]=u(r.left,t,i);return u(r.right,f,i)}else if(e=="=>"){const l=r.left;if(l.type=="infix"&&l.infix.value=="="){const f=l.left;if(f.type!="ref")return m(f,"目前只支持函数类型",i),[y.empty,t];const[n]=u(l.right,t,i),x=new h(f.value,n,t),[b]=u(r.right,x,i);return[new w(n,b,function(p){const S=new h(f.value,p,t);return u(r.right,S,!0)[0]}),t]}else return m(l,"函数头需要是绑定类型",i),[y.empty,t]}else return e=="->"?v(r.left,r.right,t,i):e=="<-"?v(r.right,r.left,t,i):(m(r,`无法处理的中缀${e}`,i),[y.empty,t])}else{if(r.type=="string")return[r.value,t];if(r.type=="number")return[r.value,t];if(r.type=="symbol")return[Symbol(r.value),t];{const e=t==null?void 0:t.get(r.value);if(e)return i||r.messages.push({type:"type",value:a(e.value)}),[e.value,t];m(r,"未找到任何定义",i)}}return[y.empty,t]}export{u as evalOneExp};
